<!doctype html><html amp lang="en"><head><meta charset="utf-8"><title>Image to ASCII</title><link rel="canonical" href="https://chpmnrssll.github.io/advanced-static-site/article/2017/10/12/Ascii.html"/><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"> <style amp-custom>
    </style><style amp-boilerplate>body{-webkit-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-moz-animation:-amp-start 8s steps(1,end) 0s 1 normal both;-ms-animation:-amp-start 8s steps(1,end) 0s 1 normal both;animation:-amp-start 8s steps(1,end) 0s 1 normal both}@-webkit-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-moz-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-ms-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@-o-keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}@keyframes -amp-start{from{visibility:hidden}to{visibility:visible}}</style><noscript><style amp-boilerplate>body{-webkit-animation:none;-moz-animation:none;-ms-animation:none;animation:none}</style></noscript> <script async src="https://cdn.ampproject.org/v0.js"></script></head><body><h2 class="post-title"><h1>Russell Chapman</h1><hr></h2> <span> 2017-10-12 00:00:00 +0000 - </span><h1 id="introduction">Introduction</h1><ul><li>description, how-to, article</li><li>custom elements, canvas, es6</li></ul><p>This article is a how-to for some of those out there old enough to remember the heyday of BBS’es and MUDs. I was always fascinated by the talent of the folks good enough to make ASCII art that looked like real images. I decided to create an algorithm that would convert a real image into its ASCII representation. There should be some little tidbits of code that you might enjoy, even if you’re not a fan of the early internet.</p><h1 id="background">Background</h1><ul><li>history<ul><li>bbs door games</li><li>roguelike</li><li>terminal</li><li>compression</li><li>downsampling</li></ul></li><li>generateCharacters<ul><li>populates the character array with { character, average: { lightness, r, g, b, a }} objects</li></ul></li><li>getCharacterAverage<ul><li>draws a white character on a black background in a small canvas</li><li>returns this characters’ average lightness from getImageDataAverage</li></ul></li><li>getImageDataAverage<ul><li>returns the average lightness and rgb for imageData</li></ul></li><li>convertImage<ul><li>iterates over a canvas in cell.width by cell.height blocks calling getMatchingCharacter</li><li>returns matching characters array for entire image</li></ul></li><li>getMatchingCharacter<ul><li>returns a character that matches this imageData block lightness</li></ul></li><li>based on the lightness for each pixel, output ASCII characters that have a matching lightness value</li><li>calculate character lightness, find matching character for each pixel</li></ul><p>Lightness is how bright a white character will appear on a black background. For example, the character “#” appears to be much brighter than “:”.</p><p>You can experiment with changing the character constants in the code to output different effects. I got particularly interesting results when I reversed the order of the output characters to get a “negative” effect.</p><h1 id="using-the-code">Using the code</h1><p>I’ve documented the code in the solution, but I will include my favorite method here for review. This method is the third type of ASCII art (mentioned above). It will take a posted file (via HTTP), read the pixels in, get the grayscale value of each pixel, then find the appropriate ASCII character to output.</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//% highlight javascript linenos %}</span>
<span class="c1">// % endhighlight %}</span>
</code></pre></div></div><p>In a nutshell, we’re doing the following:</p><ul><li>Convert the Image object into a Bitmap object</li><li>Enclose the output in HTML paragraph tags</li><li>Loop through each pixel in the bitmap, and obtain the color</li><li>Strip the color information from the pixel (see below)</li><li>Find the character to use based on the new shade (see below)</li><li>Aggregate all of the characters, then return the HTML</li></ul><h1 id="converting-to-pixels-to-lightness-values">Converting to pixels to lightness values</h1><p>The simplest way to get a lightness value is by averaging all of the pixels’ rgb components.</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div><h1 id="converting-lightness-values-to-characters">Converting lightness values to characters</h1><p>In order to convert the lightness value to a character, we average blocks of pixels cell.width by cell.height and find a character in the array with a matching value. The values I’ve included with the demo code seem to work fairly well, but feel free to experiment with different character sets.</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code></code></pre></div></div><p>You can use as few or as many constants as you like. 9 seemed to provide good results. The constant values that I chose are are as follows:</p><div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">getCharacterLightness</span><span class="p">(</span><span class="nx">character</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// clear canvas (black)</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="s2">"#000"</span><span class="p">;</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillRect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">height</span><span class="p">);</span>

  <span class="c1">// draw the character (white)</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillStyle</span> <span class="o">=</span> <span class="s2">"#FFF"</span><span class="p">;</span>
  <span class="nx">ctx</span><span class="p">.</span><span class="nx">fillText</span><span class="p">(</span><span class="nx">character</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

  <span class="kd">let</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">ctx</span><span class="p">.</span><span class="nx">getImageData</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">width</span><span class="p">,</span> <span class="nx">cell</span><span class="p">.</span><span class="nx">height</span><span class="p">).</span><span class="nx">data</span><span class="p">,</span> <span class="nx">avg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// running average of lightness for this imageData block</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">data</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">let</span> <span class="nx">lightness</span> <span class="o">=</span> <span class="p">(</span><span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">+</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="nx">data</span><span class="p">[</span><span class="nx">i</span><span class="o">+</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
    <span class="nx">avg</span> <span class="o">+=</span> <span class="nx">lightness</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">avg</span> <span class="o">/=</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">length</span> <span class="o">/</span> <span class="mi">4</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">round</span><span class="p">(</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">avg</span><span class="o">*</span><span class="mi">8</span><span class="p">,</span> <span class="mi">255</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div><p>So now, as we get the gray shade for each pixel, we just output the corresponding ASCII character. The logo of my favorite team (Denver Broncos) now appears as follows:</p><h1 id="points-of-interest">Points of interest</h1><p>Many of you will notice that I did not use an HTML Text Writer to build the HTML. Simply put, it was more overhead than I needed. StringBuilder seemed to work very well, and though it doesn’t afford me the luxury of ensuring I have the right formatting, it is by far the fastest solution.</p><p>Styling is handled by a CSS file (included). For this reason, the “class=’ascii_art’” bit was added to the opening paragraph tag. You may notice that the VS2005 IDE flags the “line-spacing” attribute in the CSS designer. Don’t worry… both IE and Firefox know how to handle it. Line spacing keeps the characters close so there is not a lot of whitespace between the lines. Also, it is important to use a MONOTYPE font (Lucida Console, Courier New, Terminal, etc.) for the font, otherwise your image will be extremely skewed.</p><p>Currently, the solution just performs a Response.Write() of the HTML to the Default.aspx page on postback. This could obviously be modified to post to a separate page, but I chose not to for purposes of simplicity and illustration.</p><p>Happy ASCII’ing!</p><p><a href="/demo/2017/10/13/Ascii-Demo.html">Demo</a></p><ul><li><a href="https://stackoverflow.com/questions/394882/how-do-ascii-art-image-conversion-algorithms-work">ASCII art image conversion algorithms</a></li><li><a href="https://github.com/EnotionZ/jscii/blob/master/src/jscii.js">jscii.js</a></li><li><a href="https://github.com/aemkei/ascii.js/blob/master/asciify.js">asciify.js</a></li><li><a href="https://www.codeproject.com/Articles/20435/Using-C-To-Generate-ASCII-Art-From-An-Image">Using C# To Generate ASCII Art From An Image</a></li></ul></body></html>